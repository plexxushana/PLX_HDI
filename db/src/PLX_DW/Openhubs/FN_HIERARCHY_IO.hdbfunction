FUNCTION "plx_analytics::FN_HIERARCHY_IO"(in_kokrs nvarchar(4) )
       
       RETURNS table(
		 "/BIC/ZIO_HIEID" NVARCHAR(32)
		,"/BIC/ZIO_OBJNM" nvarchar(30) 
		,"/BIC/ZIO_NODID"  nvarchar(08)
		, "/BIC/ZIO_NODNM" NVARCHAR(60)
		, "/BIC/ZIO_TNLVL" NVARCHAR(02)
		,"/BIC/ZIO_OBJVS"  nvarchar(01)
		,"/BIC/ZIO_PRTID"  nvarchar(60)
		,"/BIC/ZIO_LINK"   nvarchar(01)
		,"/BIC/ZIO_CLDID"  nvarchar(60)
		,"/BIC/ZIO_NXTID"  nvarchar(08)
		,"/BIC/ZIO_INTRL"  nvarchar(01)
		, "RECORDMODE"NVARCHAR(01)  ) 
       LANGUAGE SQLSCRIPT 
       SQL SECURITY INVOKER AS 
BEGIN 
    /*****************************
        Write your function logic
    ****************************/
    declare lv_zio_hieid, LV_ZIO_CRT_HIEID nvarchar(32) := 'XXXXX';
    DECLARE lv_zio_nodnm, lv_loop_zio_nodnm, lv_loop_prtid, lv_loop_ancestorid, lv_sibling   nvarchar(60) := 'AAAA'; 
    DECLARE lv_zio_tnlvl integer := 1; 
    DECLARE ARR_LEVEL1  NVARCHAR(60) ARRAY;
    declare lv_class nvarchar(04) := '0103';
    DECLARE lv_count,lv_row_count, lv_step, lv_counter, lv_num , LV_NODID  integer;
    
    
 --SELECT NODES THAT ARE TOP NODES 
    VAR_OUT =     SELECT DISTINCT SETNAME  FROM  "ECC_SETNODE"    WHERE SETCLASS = :lv_class  and  left(setname,4)= :in_kokrs AND SETNAME NOT IN ( SELECT 
                  SUBSETNAME   FROM  "ECC_SETNODE"    WHERE SETCLASS = :lv_class  and left(setname,4)= :in_kokrs) ORDER BY SETNAME ;
                  
--selct first nodes and their children. 
    var_out_child = SELECT DISTINCT SETNAME, subsetname FROM  "ECC_SETNODE"    WHERE SETCLASS = :lv_class  and  left(setname,4)= :in_kokrs AND SETNAME NOT IN ( SELECT 
                  SUBSETNAME   FROM  "ECC_SETNODE"    WHERE SETCLASS = :lv_class  and left(setname,4)= :in_kokrs ) ORDER BY SETNAME ;

--lv_zio_hieid := NEWUID();
--these are the top nodes. 
lv_zio_tnlvl :=1; 
LV_SIBLING :='';

LT_LEVEL1 =  SELECT   LEFT(NEWUID(),32) AS   "/BIC/ZIO_HIEID" 		, '0HIER_NODE' AS "/BIC/ZIO_OBJNM" 		,'1' AS "/BIC/ZIO_NODID"  
		,SETNAME AS  "/BIC/ZIO_NODNM" 
		, to_nvarchar(lv_zio_tnlvl,999)  AS "/BIC/ZIO_TNLVL" 
		,'A' AS "/BIC/ZIO_OBJVS" 
		,'0'  AS "/BIC/ZIO_PRTID"  
		,'A' AS "/BIC/ZIO_LINK"   
		,SETNAME AS  "/BIC/ZIO_CLDID"  
		,'A' AS "/BIC/ZIO_NXTID"  
		,'A' AS "/BIC/ZIO_INTRL"  
		, 'A' AS "RECORDMODE"
		FROM :var_out ; 
		
LT_LEVEL1_CHILD =  SELECT   LEFT(NEWUID(),32) AS   "/BIC/ZIO_HIEID" 		, '0COORDER' AS "/BIC/ZIO_OBJNM" 		,'1' AS "/BIC/ZIO_NODID"  
		,SETNAME AS  "/BIC/ZIO_NODNM" 
		, to_nvarchar(lv_zio_tnlvl, 999)  AS "/BIC/ZIO_TNLVL" 
		,'A' AS "/BIC/ZIO_OBJVS" 
		,'0'  AS "/BIC/ZIO_PRTID"  
		,'A' AS "/BIC/ZIO_LINK"   
		,SETNAME AS  "/BIC/ZIO_CLDID"  
		,'A' AS "/BIC/ZIO_NXTID"  
		,'A' AS "/BIC/ZIO_INTRL"  
		, 'A' AS "RECORDMODE"
		FROM :var_out_CHILD ; 

	ARR_LEVEL1  := ARRAY_AGG(:lt_LEVEL1."/BIC/ZIO_NODNM" ORDER BY "/BIC/ZIO_NODNM");
	
	lv_count    := CARDINALITY(:arr_level1);
	lv_row_count := 1; 
	lv_step :=1;
	lv_counter := 1; 
-- let's find  the children
-- there might be entries in SETLEAF only and not in SETNODE. Will add them later. for ex: Node 123 has only 3 leafs and no subnodes. 
LV_ZIO_CRT_HIEID := '' ; 

LT_HIERARCHY_SIBLINGS = SELECT  ''  AS "/BIC/ZIO_PRTID" , 	'' AS "/BIC/ZIO_CLDID"  FROM DUMMY ; 


--FOR lv_row_count IN 1..lv_count  do
FOR lv_row_count IN 1..1  do
lv_zio_nodnm := 	:ARR_LEVEL1[lv_counter]; 
lv_loop_zio_nodnm := 	:ARR_LEVEL1[lv_counter]; 
LV_NODID :=1;  
lv_loop_prtid := '1700_PAYIO';
--this loop will take each setname and it will find the parent-child rows in teh table. we need to have the Top SetName in array so we can search one by one. 

--lt_hierarchy = select * from :lt_level1 where "/BIC/ZIO_NODNM"  = ARR_LEVEL1[lv_counter];
lt_hierarchy = select * from :lt_level1 where "/BIC/ZIO_NODNM"  = :lv_zio_nodnm;
SELECT "/BIC/ZIO_HIEID" INTO LV_ZIO_CRT_HIEID  FROM :LT_LEVEL1 WHERE "/BIC/ZIO_NODNM"  = :lv_zio_nodnm;

	while 1 = 1 do

		LT_HIERARCHY_TMP = 
		    SELECT  top 1 
		    	 LV_ZIO_CRT_HIEID AS  "/BIC/ZIO_HIEID" 		,
		    	 '0HIER_NODE' AS "/BIC/ZIO_OBJNM" 		,
		    	 :lv_nodid AS "/BIC/ZIO_NODID"  , 
			     :lv_loop_zio_nodnm AS "/BIC/ZIO_NODNM" , 
		         to_nvarchar(:lv_zio_tnlvl + 1,999) AS "/BIC/ZIO_TNLVL"  ,
		        'A' AS "/BIC/ZIO_OBJVS" ,
			    B.SETNAME AS "/BIC/ZIO_PRTID" , 	
			    'A' AS "/BIC/ZIO_LINK"  ,
			    B.SUBSETNAME AS "/BIC/ZIO_CLDID", 
			    'A' AS "/BIC/ZIO_NXTID"  	,
			    'A' AS "/BIC/ZIO_INTRL"  ,
				'A' AS "RECORDMODE"
			    
		    FROM "ECC_SETNODE" as B
			WHERE B.SETCLASS =  :lv_class 
		    and  b.setname =  :lv_loop_prtid
		    and  b.subsetname not in (select "/BIC/ZIO_CLDID" from :LT_HIERARCHY_SIBLINGS where "/BIC/ZIO_PRTID" = :lv_loop_prtid ) 
		    order by b.lineid;
		    
-- builds the siblings table to be used backward once the last heir has been found. :-) 
-- for ex: if the top node has 3 nodes (node1, node2, node3), it will go down node1 and find any children, then it has to go to node2 which is a sibling meaning it has to go back up 
-- and start getting the children of node2 and so on. this can be achieved by keeping track of siblings in another table
LT_HIERARCHY_SIBLINGS = 
		    SELECT 
		    	
			    B.SETNAME AS "/BIC/ZIO_PRTID" , 	
			    B.SUBSETNAME AS "/BIC/ZIO_CLDID" 
			   
		    FROM "ECC_SETNODE" as B
			WHERE B.SETCLASS =  :lv_class 
		    and  b.setname =  :lv_loop_prtid
		    and  b.subsetname not in (select "/BIC/ZIO_CLDID" from :LT_HIERARCHY where "/BIC/ZIO_PRTID" = :lv_loop_prtid ) 
		    order by b.lineid;
	
	    SELECT COUNT(*) INTO lv_NUM FROM :LT_HIERARCHY_TMP;
	
	    if :LV_NUM = 0 then 
	--go to previous child/brother if any ancestor exist, until it reaches the top node.  lol...second heir in throne :-)   the search has to back up.
    	select top 1 "/BIC/ZIO_CLDID" into lv_sibling from :LT_HIERARCHY_SIBLINGS WHERE "/BIC/ZIO_PRTID" = :lv_loop_ancestorid  ; 
    	--and subsetname not in ( 	--	   select "/BIC/ZIO_CLDID" from :LT_HIERARCHY where "/BIC/ZIO_PRTID" = :lv_loop_ancestorid 	); 
		    if :lv_sibling = '' then 
	               break;
	          end if; 
	    end if;
--this become the child now.
IF :lv_sibling = '' THEN 
  lv_loop_ancestorid := :lv_loop_prtid;
  LV_NODID := :LV_NODID + 1 ; 
-- hold into a variable the name of the new parent. 

   select top 1 subsetname  into  lv_loop_prtid  from "ECC_SETNODE" as B WHERE B.SETCLASS =  :lv_class  and  b.setname =  :lv_loop_ancestorid  
--and subsetname not in (		   select "/BIC/ZIO_CLDID" from :LT_HIERARCHY where "/BIC/ZIO_PRTID" = :lv_loop_ancestorid 	)  
   order by b.lineid;

ELSE 
   lv_loop_prtid:= :lv_loop_ancestorid;
END IF ; 

	    LT_HIERARCHY =
		    SELECT 	   "/BIC/ZIO_HIEID" 		,
		    	  "/BIC/ZIO_OBJNM" 		,
		    	 "/BIC/ZIO_NODID"  , 
			      "/BIC/ZIO_NODNM" , 
		         "/BIC/ZIO_TNLVL"  ,
		         "/BIC/ZIO_OBJVS" ,
			   "/BIC/ZIO_PRTID" , 	
			    "/BIC/ZIO_LINK"  ,
			    "/BIC/ZIO_CLDID", 
			    "/BIC/ZIO_NXTID"  	,
			     "/BIC/ZIO_INTRL"  ,
				 "RECORDMODE"
		    from :LT_HIERARCHY
	        
	        UNION
		    
		    SELECT    "/BIC/ZIO_HIEID" 		,
		    	  "/BIC/ZIO_OBJNM" 		,
		    	 "/BIC/ZIO_NODID"  , 
			      "/BIC/ZIO_NODNM" , 
		         "/BIC/ZIO_TNLVL"  ,
		         "/BIC/ZIO_OBJVS" ,
			   "/BIC/ZIO_PRTID" , 	
			    "/BIC/ZIO_LINK"  ,
			    "/BIC/ZIO_CLDID", 
			    "/BIC/ZIO_NXTID"  	,
			     "/BIC/ZIO_INTRL"  ,
				 "RECORDMODE"
		    from :LT_HIERARCHY_TMP;
		    
		    LT_HIERARCHY_SIBLINGS = SELECT * fROM :LT_HIERARCHY_SIBLINGS 
		                            UNION 
		                            SELECT * fROM :LT_HIERARCHY_SIBLINGS;
	
--	    lv_zio_tnlvl := lv_zio_tnlvl + 1;

	end while;
--  lv_counter := lv_counter + 1 ;
       
	END FOR;


-- LETS'EXCLUDE THE BOTTOM ONES.  IF THEY HAVE AN ENTRY IN SETLEAF THEN IT MEANS THEY ARE BOTTOMS AND NEED TO BE EXCLUDED
RETURN   
    
 SELECT   * 
		FROM :LT_HIERARCHY ; 
END;